---
title: PoEAA ch17 Server Session State
tags:
- PoEAA
- 勉強メモ
- デザインパターン
date: 2019-09-21T18:45:37+09:00
URL: https://wand-ta.hatenablog.com/entry/2019/09/21/184537
EditURL: https://blog.hatena.ne.jp/wand_ta/wand-ta.hatenablog.com/atom/entry/26006613437621686
bibliography: https://martinfowler.com/books/eaa.html
-------------------------------------

# Server Session State

> Keeps the session state on a server system in a serialized form.


## How It Works

- 最も単純な形としては、アプリケーションサーバのメモリ上にセッションオブジェクトを持つ
    - セッションIDで引く連想配列
    - クライアントはセッションIDを保持し、サーバへのリクエスト時に渡す
    - サーバはセッションIDを受け取り、当該セッションのセッションオブジェクトを読み込む
- 前提
    - サーバが十分なメモリを積んでいる
    - アプリケーションサーバは1台である
        - クラスタリング、fail-overなし
        - 唯一のアプリケーションサーバが落ちたら全てのセッション情報が失われる
- 上記前提が崩れる場合は、もう少し複雑なパターンを導入することになる
- メモリ容量問題
    - Server Session Stateパターンへのおもな反論のひとつ
    - 避けるためには、メモリ上で保持するのではなく、Memento (GoF)にシリアライズして永続化する
        - どんな形にシリアライズする？
        - どこに永続化する？
- セッション情報をどんな形にシリアライズする
    - テキスト
        - XMLとか
    - バイナリ

|                      | テキスト   | バイナリ     |
|----------------------|------------|--------------|
| コード量             | 多少は必要 | ほとんど不要 |
| human-readable       | yes        | no           |
| サイズ               | 大         | 小           |
| バージョニングの問題 | なし       | あり         |

- バイナリの場合、デシリアライズ先のクラスに変更・更新が加わるとデシリアライズ不可能になる
    - フィールドが1つ追加されたらもう駄目
    - 困ることはレアケース
        - 例: 無停止システムをクラスタリングしていて、アップデート時に新旧クラスが混在する場合など
- セッション情報をどこに永続化する
    - アプリケーションサーバ自身
        - ファイルシステムやローカルDB
        - メリデメ
            - シンプル
            - クラスタリングやfailoverをサポートできない
    - 外部の共通サーバ
        - ファイルシステムやDB
        - メリデメ
            - クラスタリングやfailoverをサポート
            - passivate/activateに時間がかかる
                - 【補】passivate: メモリ上のセッション情報を永続化し、メモリ上から削除
                    - activateはその逆
                - 【補】リモートだから時間がかかるということ
        - 永続化先がDBの場合、Database Session Stateパターンとどう違うの
            - 線引きはあいまい
            - 著者は、セッション情報の保存の仕方で区別
                - Server Session State
                    - Serialized LOBとして保存
                - Database Session State
                    - 普通のレコードよろしく表形式で保存
- 特に2Cのサービスの場合、ごみ掃除が必要
    - 長く残っているセッションを定期削除するdaemonを動かす？
        - セッション情報のテーブル上で競合をおこしてしまう
            - 【補】ロッキングが起きるということかな
    - Kai Yu氏のメソッド
        - セッション情報テーブルを12個にパーティショニング
        - 2時間ごとにローテーション
            - insertは一番新しいパーティションに対して行う
            - 一番古いパーティションを掃除
        - 全てのセッションは24時間で切れることになる
            - 問題になることはレアケース
- 今日び(本書執筆当時)では、アプリケーションサーバ自身が自動的にセッションをサポートしてくれたりする
    - クラスタリングやfailoverをサポート

### Java Implementation

- 略

### .NET implementation

- 略


## When to Use It

- Session State系パターンの中で最もシンプル
    - たいていのケースにおいて、プログラミングほぼ不要
        - クラスタリングやfailoverが...
            - 不要な場合、単にメモリ上オブジェクトで済ます
            - 必要な場合、セッション情報を外部サーバに出すが、アプリケーションサーバがよろしくやってくれる
    - 自分で外部DBにセッション情報を出すにしても、データを表型に変換する(Database Session State)よりもSerialized LOB(Server Session State)のほうが楽
- クラスタリングやfailoverをサポートするために自前実装が増えると、他のパターンより苦労するかも
    - 下記のような場合、他のパターンを検討する
        - セッション情報が少量
            - 【補】Client Server Stateパターンが適する
        - データを容易に表型に変換できる
            - 【補】Database Server Stateパターンが適する

----------------------------------------

# 英語

- passivate/activate
    - サーバーのクラスタリング界隈の言葉
- contention
    - 競合
- unceremoniously
    - 突然
        - 突然ログインが切れる、といった文脈
